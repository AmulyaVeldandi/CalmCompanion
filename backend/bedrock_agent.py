from __future__ import annotations

import json
import os
from typing import Any, Dict, Optional

try:
    import boto3
    from botocore.exceptions import BotoCoreError, ClientError
except ImportError as exc:  # pragma: no cover - boto3 must be installed in runtime
    raise ImportError("boto3 is required for the Bedrock agent integration.") from exc


DEFAULT_MODEL_ID = os.getenv(
    "BEDROCK_MODEL_ID", "anthropic.claude-3-sonnet-20240229-v1:0"
)
DEFAULT_MAX_TOKENS = int(os.getenv("BEDROCK_MAX_TOKENS", "512"))
DEFAULT_TEMPERATURE = float(os.getenv("BEDROCK_TEMPERATURE", "0.2"))


def _session_from_env() -> boto3.session.Session:
    """Create a boto3 session using standard AWS environment variables."""
    region = os.getenv("AWS_REGION") or os.getenv("AWS_DEFAULT_REGION")
    if not region:
        raise RuntimeError(
            "AWS region is not configured. Set AWS_REGION or AWS_DEFAULT_REGION."
        )

    session_kwargs: Dict[str, Any] = {"region_name": region}
    access_key = os.getenv("AWS_ACCESS_KEY_ID")
    secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
    session_token = os.getenv("AWS_SESSION_TOKEN")

    if access_key and secret_key:
        session_kwargs["aws_access_key_id"] = access_key
        session_kwargs["aws_secret_access_key"] = secret_key
    if session_token:
        session_kwargs["aws_session_token"] = session_token

    return boto3.Session(**session_kwargs)


def _format_context(context: Optional[Dict[str, Any]]) -> str:
    """Flatten the context dictionary into a readable string for the prompt."""
    if not context:
        return ""

    chunks = []
    for key, value in context.items():
        try:
            if isinstance(value, (dict, list)):
                formatted_value = json.dumps(value, ensure_ascii=False, indent=2)
            else:
                formatted_value = str(value)
        except (TypeError, ValueError):
            formatted_value = str(value)
        chunks.append(f"{key}: {formatted_value}")
    return "\n".join(chunks)


def run_reasoning_agent(user_input: str, context: Dict[str, Any] | None = None) -> str:
    """
    Call the Bedrock AgentCore API (Claude 3 Sonnet) to produce an action plan.

    Args:
        user_input: The latest user utterance or task description.
        context: Optional structured context that should inform the agent.

    Returns:
        The action plan text generated by the agent.

    Raises:
        RuntimeError: If the Bedrock invocation fails or produces no output.
    """

    if not user_input or not user_input.strip():
        raise ValueError("user_input must be a non-empty string.")

    session = _session_from_env()
    client = session.client("bedrock-runtime")

    context_block = _format_context(context)
    prompt_parts = [
        "You are a caregiving assistant planning supportive next steps.",
        "Produce a clear, step-by-step action plan responding to the user.",
        "Return only the plan text.",
    ]
    if context_block:
        prompt_parts.append(f"Context:\n{context_block}")
    prompt_parts.append(f"User Input:\n{user_input.strip()}")

    messages = [
        {
            "role": "system",
            "content": [
                {
                    "type": "text",
                    "text": "You are a structured reasoning agent. Focus on actionable caregiving guidance.",
                }
            ],
        },
        {
            "role": "user",
            "content": [{"type": "text", "text": "\n\n".join(prompt_parts)}],
        },
    ]

    inference_config = {
        "maxTokens": DEFAULT_MAX_TOKENS,
        "temperature": DEFAULT_TEMPERATURE,
    }

    # Request reasoning output when available (Claude 3 Sonnet supports action plans).
    additional_fields: Dict[str, Any] = {
        "reasoningConfig": {"enablePlan": True, "budgetTokens": DEFAULT_MAX_TOKENS}
    }

    try:
        response = client.converse(
            modelId=DEFAULT_MODEL_ID,
            messages=messages,
            inferenceConfig=inference_config,
            additionalModelRequestFields=additional_fields,
        )
    except (BotoCoreError, ClientError) as exc:
        raise RuntimeError(f"Failed to invoke Bedrock agent: {exc}") from exc

    plan_text = _extract_plan_text(response)
    if not plan_text:
        raise RuntimeError("Bedrock agent returned an empty action plan.")

    return plan_text.strip()


def _extract_plan_text(response: Dict[str, Any]) -> str:
    """Pull the most relevant text payload from the Bedrock response."""
    if not response:
        return ""

    # 1. Check for explicit reasoning/action plan in additional fields.
    additional_fields = response.get("additionalModelResponseFields") or {}
    reasoning = additional_fields.get("reasoning") or {}
    if isinstance(reasoning, dict):
        action_plan = reasoning.get("actionPlan") or reasoning.get("plan")
        if isinstance(action_plan, str) and action_plan.strip():
            return action_plan

    # 2. Fall back to assistant text output.
    outputs = response.get("output") or []
    text_chunks = []
    for message in outputs:
        contents = message.get("content") or []
        for item in contents:
            if item.get("type") == "text" and item.get("text"):
                text_chunks.append(item["text"])

    return "\n".join(text_chunks).strip()
